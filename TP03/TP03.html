<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Trésor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script src="js/libs/ammo.wasm.js"></script>

		<script type="module">

			// ============== IMPORTS ==============
			import * as THREE from '../build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page
			import {OBJLoader} from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import {MTLLoader} from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader

			import { Octree } from './jsm/math/Octree.js';
			import { Capsule } from './jsm/math/Capsule.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let pointLight, spotLightHelper, shadowCameraHelper;
			let obg,obc;
			let i,y;
			let animeState;
			animeState = i = 0;

			let mixer;
			let mixerArray = new Array();
			let objArray = new Array();
			const clock = new THREE.Clock();
			let clockBuffer = 0;
			let positionX, positionY;
			let action, objAction;


			// geometrie terrain
			const terrainWidthExtents = 1000;
			const terrainDepthExtents = 1000;
			const terrainWidth = 1280;
			const terrainDepth = 128;
			const terrainHalfWidth = terrainWidth / 2;
			const terrainHalfDepth = terrainDepth / 2;
			const terrainMaxHeight = 8;
			const terrainMinHeight = - 2;

			let heightData = null;
			let ammoHeightData = null;
			let time = 0;
			const objectTimePeriod = 3;
			let timeNextSpawn = time + objectTimePeriod;
			const maxNumObjects = 30;


			// Physics variables
			let collisionConfiguration;
			let dispatcher;
			let broadphase;
			let solver;
			let physicsWorld;
			const dynamicObjects = [];
			let transformAux1;


			// ============== VARIABLES DE DEFINITION ==============
			const nbrPerso = 1;
			const STEPS_PER_FRAME = 5; // vitesse perso
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			let objMove = new Array();


			// ============== APPEL FONCTIONS ==============
			Ammo().then( function ( AmmoLib ) {
				Ammo = AmmoLib;
				init();
				animate();
				buildGui();
			} );
			// init();
			// animate();
			// buildGui();

			// ============== FONCTIONS ==============
			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );

				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 0.3 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 300, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres
				scene.add(pointLight);

				// ===== SPOT LIGHT =====
				const spotLight = new THREE.SpotLight( 0xFFFFFF, 12); // (couleur, intensite)
				spotLight.position.set( 0, 300, 0 ); // position
				spotLight.angle = Math.PI / 6; // angle d'ouverture
				spotLight.decay = 1.5; // diminution avec la distance
				spotLight.distance = 300; // distance
				spotLight.castShadow = true; // renvoie une ombres
				scene.add( spotLight );

				// ===== HELPER =====
				spotLightHelper = new THREE.SpotLightHelper( spotLight ); // ajoute des helpers pour le spotLight
				spotLightHelper.visible = false; // pas visible
				scene.add( spotLightHelper ); // ajout des helpers à la scene (blanc)

				shadowCameraHelper = new THREE.CameraHelper( spotLight.shadow.camera ); // ajoute des helpers pour la camera d'ombres
				shadowCameraHelper.visible = false; // pas visible
				scene.add( shadowCameraHelper ); // ajout des helpers à la scene (orange)

				// ============== TEXTURES ==============
				// ===== LOADERS =====
				const loader = new THREE.TextureLoader();
				loader.setPath( 'textures/' ); // emplacement des textures

				const loaderMTL = new MTLLoader(); // mtl => fichier qui contient les textures d'un objet 3d
				loaderMTL.setPath( 'models/' ); // emplacement des fichiers
				loaderMTL.setMaterialOptions( { side: THREE.DoubleSide } ); // texture appliquer des 2 cotés de l'objet

				const loaderFBX = new FBXLoader();
				loaderFBX.setPath( 'models/' ); // emplacement des fichiers

				// ===== MARCHES =====
				const marcheT = [ // texture par face
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}), //MeshPhongMaterial = mesh mat
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')})
				];

				// ===== CONE LUMIERE =====
				const coneT = new THREE.MeshBasicMaterial({	color: 0xFFFFFF, opacity: 0.1, transparent: true, side: THREE.DoubleSide});

				// ============== OBJECTS ==============
				// ===== MARCHES =====
				const marcheA = new THREE.BoxGeometry( 200, 20, 200 ); // dimensions
				const marcheB = new THREE.BoxGeometry( 150, 20, 150 );
				const mA = new THREE.Mesh( marcheA, marcheT ); // (dimensions, texture)
				const mB = new THREE.Mesh( marcheB, marcheT );
				mA.position.y = 10; // position
				mB.position.y = 30; // hauteur mA + 10
				mA.receiveShadow = true; // reçoi les ombres
				mB.receiveShadow = true;
				scene.add( mA ); // ajout
				scene.add( mB );

				// ===== CONE =====
				const coneGeo = new THREE.ConeGeometry( 110, 400, 60 ); // dimension (radius, hauteur, segments)
				const cone = new THREE.Mesh(coneGeo, coneT); // (dimensions, texture)
				cone.position.set( 0, 200, 0 ); // position
				scene.add(cone);

				// ============== SOL ===============
				const geometry = new THREE.PlaneGeometry( terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1 );
				geometry.computeVertexNormals();
				geometry.rotateX( - Math.PI / 2 );
				const groundMaterial = new THREE.MeshPhongMaterial( { color: 0xFFFFFF } );
				const terrainMesh = new THREE.Mesh( geometry, groundMaterial );
				terrainMesh.receiveShadow = true;
				terrainMesh.castShadow = true;
				terrainMesh.position.set( 0, -100, 0 );
				scene.add( terrainMesh );

				// ============== IMPORT OBJET ==============
				// ===== CAVE =====
				loaderMTL.load('cave.mtl', (mtl) => { // new texture d'obj
					const caveOBJ = new OBJLoader(); // new obj
					caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
					caveOBJ.load('models/cave.obj', (obj) => { // charge l'objet
						obj.position.set(0,60,0); // x, z, y

						shape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );
						shape.setMargin( margin );

						// ===== PHYSIQUE =====
						shape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );
						shape.setMargin( margin );
						obj.add(new THREE.BoxHelper(obj, 0xffffff));

						const mass = objectSize * 5;
						const localInertia = new Ammo.btVector3( 0, 0, 0 );
						shape.calculateLocalInertia( mass, localInertia );
						const transform = new Ammo.btTransform();
						transform.setIdentity();
						const pos = obj.position;
						transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
						const motionState = new Ammo.btDefaultMotionState( transform );
						const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );
						const body = new Ammo.btRigidBody( rbInfo );

						obj.userData.physicsBody = body;
						scene.add(obj); // ajout de l'obj à la scène
						dynamicObjects.push( obj );
						physicsWorld.addRigidBody( body );
					});
				});

				// ===== GEMME =====
				loaderMTL.load('gemme.mtl', (mtl) => { // new texture d'obj
					const gemmeOBJ = new OBJLoader(); // new obj
					gemmeOBJ.setMaterials(mtl); // ajout les texture a l'obj
					gemmeOBJ.load('models/gemme.obj', (obj) => { // charge l'objet
						obj.position.set(0,45,0); // x, z, y
						obj.traverse( function ( child ) { // Ombres
            	if ( child instanceof THREE.Mesh ) { // cree un objet transparent autour l'objet qui prend et renvoie les ombres
              	child.receiveShadow = true;
	              child.castShadow = true;
              }
            });
						obg = obj; // obliger de mettre l'objet dans une variable externe pour pouvoir l'appeler ensuite dans d'autre fonction
						scene.add(obj); // ajout de l'obj à la scène
					});
				});


				// ======== CHEST =======
				// ===== CHEST TOP =====
				loaderMTL.load('chestTop.mtl', (mtl) => { // new texture d'obj
					const chtOBJ = new OBJLoader(); // new obj
					chtOBJ.setMaterials(mtl); // ajout les texture a l'obj
					chtOBJ.load('models/chestTop.obj', (obj) => { // charge l'objet
						obj.position.set(0,75,-25); // x, z, y
						obj.traverse( function ( child ) {
            	if ( child instanceof THREE.Mesh ) {
              	child.receiveShadow = true;
	              child.castShadow = true;
              }
            });
						obc = obj;
						scene.add(obj); // ajout de l'obj à la scène
					});
				});

				// ===== CHEST BOTTOM =====
				loaderMTL.load('chestBottom.mtl', (mtl) => { // new texture d'obj
					const caveOBJ = new OBJLoader(); // new obj
					caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
					caveOBJ.load('models/chestBottom.obj', (obj) => { // charge l'objet
						obj.position.set(0,40,0); // x, z, y
						obj.traverse( function ( child ) {
            	if ( child instanceof THREE.Mesh ) {
              	child.receiveShadow = true;
	              child.castShadow = true;
              }
            });
						scene.add(obj); // ajout de l'obj à la scène
					});
				});

				// ===== CHAMPIS BOYS =====
				const objectSize = 3;
				const margin = 0.05;
				let shape = null;
		    let radius, height;
				radius = height = objectSize;
				// height = objectSize
				const minDist = -200;
				const maxDist = 200;
				const angle = [0,90,180,-90,-180];
				for(y = 0; y < nbrPerso; y++){
					loaderFBX.load( 'champiWalk.fbx', function ( obj ) {
						mixer = new THREE.AnimationMixer( obj );
						const action = mixer.clipAction( obj.animations[ 0 ] );
						mixerArray.push(mixer);
						action.play();
						obj.traverse( function ( child ) {
							if ( child.isMesh ) {
								child.castShadow = true;
								child.receiveShadow = true;
							}
						} );
						positionX = Math.floor(Math.random() * (maxDist - minDist + 1) ) + minDist;
						positionY = Math.floor(Math.random() * (maxDist - minDist + 1) ) + minDist;
						if(positionX < 50 && positionX > -50){positionX = 50;} // evite d'avoir les persos dans les marches
						if(positionY < 50 && positionY > -50){positionY = 50;}
						obj.position.set(positionX, 100, positionY);
						obj.rotation.y = angle[parseInt(Math.floor(Math.random() * 5))];

						// ===== PHYSIQUE =====
						shape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );
						shape.setMargin( margin );
	          obj.add(new THREE.BoxHelper(obj, 0xffffff));

						const mass = objectSize * 5;
						const localInertia = new Ammo.btVector3( 0, 0, 0 );
	 					shape.calculateLocalInertia( mass, localInertia );
						const transform = new Ammo.btTransform();
						transform.setIdentity();
						const pos = obj.position;
						transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
						const motionState = new Ammo.btDefaultMotionState( transform );
						const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );
						const body = new Ammo.btRigidBody( rbInfo );

						obj.userData.physicsBody = body;
						dynamicObjects.push( obj );
						physicsWorld.addRigidBody( body );
						objArray.push(obj);
						scene.add( obj );

					// }
					} );
				}
				// for(y = 0; y < mixerArray.length; y++){
				// 	console.log(mixerArray[y]);
				// }

				// ============= CAMERA =============
				camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.set(0,120,250);
				camera.lookAt(0, 30, 0); // cordonnées du point regarder par la camera
				controls = new OrbitControls( camera, renderer.domElement ); // Faire bouger la caméra avec la souris
				// controls.minDistance = 150; // distance min
				// controls.maxDistance = 300; // distance max
				// controls.maxPolarAngle = Math.PI / 2.3;

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'keyup', function(e){ // 'keyup' == touche presser
					if(e.keyCode == 32){ if(animeState == 0){ animeState = 1; } } // si touche espace presser =>    32 == keycode de la touche espace
				});

				initPhysics();

			}

			function initPhysics() {

				// Physics configuration

				collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
				broadphase = new Ammo.btDbvtBroadphase();
				solver = new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
				physicsWorld.setGravity( new Ammo.btVector3( 0, - 6, 0 ) );

				// Create the terrain body

				const groundShape = createTerrainShape();
				const groundTransform = new Ammo.btTransform();
				groundTransform.setIdentity();
				// Shifts the terrain, since bullet re-centers it on its bounding box.
				// groundTransform.setOrigin( new Ammo.btVector3( 0, ( terrainMaxHeight + terrainMinHeight ) / 2, 0 ) );
				groundTransform.setOrigin( new Ammo.btVector3( 0, 60, 0 ) );
				const groundMass = 0;
				const groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
				const groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
				const groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );

				physicsWorld.addRigidBody( groundBody );

				// groundBody.add(new THREE.BoxHelper(physicsWorld, 0xffffff));

				transformAux1 = new Ammo.btTransform();

			}

			function createTerrainShape() {

				// This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored
				const heightScale = 1;

				// Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.
				const upAxis = 1;

				// hdt, height data type. "PHY_FLOAT" is used. Possible values are "PHY_FLOAT", "PHY_UCHAR", "PHY_SHORT"
				const hdt = "PHY_FLOAT";

				// Set this to your needs (inverts the triangles)
				const flipQuadEdges = false;

				// Creates height data buffer in Ammo heap
				ammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );

				// Creates the heightfield physics shape
				const heightFieldShape = new Ammo.btHeightfieldTerrainShape(
					terrainWidth,
					terrainDepth,
					ammoHeightData,
					heightScale,
					terrainMinHeight,
					terrainMaxHeight,
					upAxis,
					hdt,
					flipQuadEdges
				);

				// Set horizontal scale
				const scaleX = terrainWidthExtents / ( terrainWidth - 1 );
				const scaleZ = terrainDepthExtents / ( terrainDepth - 1 );
				heightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );

				heightFieldShape.setMargin( 0.05 );

				return heightFieldShape;

			}

			// ============== GUI ==============
			function buildGui() {

				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex() //getHex() => recup la couleur en hexa
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.open(); // Ajout du gui à la scene
			}


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function movePerso(){
				console.log("move");
				for(y = 0; y < nbrPerso; y++){
					switch(objArray[y].rotation.y){
						case 0: objArray[y].position.z += .1; break;
						case 90: objArray[y].position.x += .1; break;
						case -90: objArray[y].position.x -= .1; break;
						case 180: objArray[y].position.z -= .1; break;
						case -180: objArray[y].position.z -= .1; break;
						case 270: objArray[y].rotation.y = -90; break;
						case -270: objArray[y].rotation.y = 90; break;
					}
					console.log(objArray[y].position);
				}
			}

			function updatePhysics( deltaTime ) {

				physicsWorld.stepSimulation( deltaTime, 10 );

				// Update objects
				// let aaa;
				for ( let aaa = 0; aaa < dynamicObjects.length; aaa++ ) {
					objArray[0].position.x += 0.1;
					const objThree = dynamicObjects[ i ];
					// objThree.position.
					const objPhys = objThree.userData.physicsBody;
					const ms = objPhys.getMotionState();
					if ( ms ) {
						console.log(objThree.position);

						ms.getWorldTransform( transformAux1 );
						const p = transformAux1.getOrigin();
						const q = transformAux1.getRotation();
						objThree.position.set( p.x(), p.y(), p.z() );
						objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

					}

				}

			}

			function animate() {

				requestAnimationFrame( animate ); // recup fps
				const delta = clock.getDelta();

				// ====== PHYSIQUE =====
				// updatePhysics( delta );
				render();
				if(animeState == 1){ // 1er étape animation (ouvrir le coffre et sortir le gemme)
					if(i >= 360){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 2; // passe à la 2e étape de l'animation
						i = 0;
					} else {
						obc.rotation.x -= 0.01;
						obg.position.y += 0.2;
						obg.rotation.y += 0.05;
						i++;
					}
				} else if(animeState == 2){ // 2e étape animation (refermer le coffre et ranger le gemme)
					if(i >= 360){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 0;
						i = 0;
					} else {
						obc.rotation.x += 0.01;
						obg.position.y -= 0.2;
						obg.rotation.y += 0.05;
						i++;
					}
				};

				// ===== ANIMATION DES FBX =====
				if ( mixerArray ){
					for(y = 0; y < mixerArray.length; y++){
						mixer = mixerArray[y];
						mixer.timeScale = .5;
						mixer.update( delta );
					}
				}

				// ===== DEPLACEMENT ALEATOIRE =====
				if(parseInt(clock["oldTime"]) - clockBuffer > 3000){
					clockBuffer = parseInt(clock["oldTime"]);
					for(y = 0; y < objArray.length; y++){
						// if(parseInt(clock["oldTime"]) - clockBuffer > 3000+(y*100)){
							action = parseInt(Math.floor(Math.random() * 10) + 1);
							objAction = objArray[y];
							// console.log('move: '+y);
							// console.log(action);
							switch(action) {
								case 1: objAction.rotation.y += 90 ; break;
								case 2: objAction.rotation.y -= 90 ; break;
						}

						// for(var vertexIndex = 0; vertexIndex < objAction.geometry.vertices.length; vertexIndex++){
						// 	var localVertex = objAction.geometry.vertices[vertexIndex].clone();
						// 	var globalVertex = objAction.matrix.multiplyVector3(localVertex);
						// 	var directionVector = globalVertex.subSelf( objAction.position );
						//
						// 	var ray = new THREE.Ray( objAction.position, directionVector.clone().normalize() );
						// 	var collisionResults = ray.intersectObjects( collidableMeshList );
						// 	if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
						// 		console.log(y+': touche');
						// 	}
						// }
				// }
					// console.log(parseInt(clock["oldTime"]));
					}
				}

				// movePerso();


				updatePhysics( delta );
				renderer.render( scene, camera );
				stats.update();

			}

			function render(){
				const deltaTime = clock.getDelta();
				// movePerso();

			}

    </script>
  </body>
</html>
